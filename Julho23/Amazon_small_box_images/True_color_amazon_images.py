# -*- coding: utf-8 -*-
"""
Created on Mon Jul 17 17:21:21 2023

@author: thiag
"""



# -*- coding: utf-8 -*-
"""GOES-16 products processing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tF-GMOUDRPZeFwslQd0fOeL_H1Jtu5mM

Fire product: 

OR_ABI-L2-FDCF-M3_G16_sYYYYJJJHHMMSSs_eYYYYJJJHHMMSSs_cYYYYJJJHHMMSSs.nc

Multi channel product - full disk:-
OR_ABI-L2-MCMIPF-M3_G16_s20181781922189_e20181781924562_c20181781925075.nc
"""

#!pip install s3fs xarray[complete] cartopy

#colorbarmin=0
#colorbarmax=0.5
#colorbarticknum=5
#cb.mappable.set_clim(colorbarmin,colorbarmax)
#cb.set_ticks(np.linspace(colorbarmin,colorbarmax,num=colorbarticknum+1))

# Commented out IPython magic to ensure Python compatibility.
from io import BytesIO
import s3fs
import xarray as xr
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import cartopy.crs as ccrs
import numpy as np
import cartopy
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER as LongitudeFormatter
from cartopy.mpl.gridliner import LATITUDE_FORMATTER as LatitudeFormatter
from pyproj import Proj
import matplotlib.patches as mpatches



def test_function(nevermind):
    files = fs.ls('noaa-goes16/ABI-L2-MCMIPF/2020/'+str(232).zfill(3)+'/'+str(14).zfill(2)+'/') # list of 6 files for 2022 day 200, UTC time 15:00, 15:10, 15:20, ..., 15:50
    print('noaa-goes16/ABI-L2-FDCF/2020/'+str(232).zfill(3)+'/'+str(14).zfill(2)+'/')
    print(files)
    with fs.open(files[5], 'rb') as f:
      print('entrou aqui')  
      ds0 = xr.open_dataset(BytesIO(f.read()), engine='h5netcdf')
    # R = C['CMI_C02'].data
    # G = C['CMI_C03'].data
    # B = C['CMI_C01'].data  
    
    # Load the three channels into appropriate R, G, and B variables
    R = ds0.CMI_C02
    G = ds0.CMI_C03
    B = ds0.CMI_C01
    # Apply range limits for each channel. RGB values must be between 0 and 1
    R = np.clip(R, 0, 1)
    G = np.clip(G, 0, 1)
    B = np.clip(B, 0, 1)
    # Apply a gamma correction to the image to correct ABI detector brightness
    gamma = 2.2
    R = np.power(R, 1/gamma)
    G = np.power(G, 1/gamma)
    B = np.power(B, 1/gamma)
    # Calculate the "True" Green
    G_true = 0.45 * R + 0.1 * G + 0.45 * B
    G_true = np.clip(G_true, 0, 1)  # apply limits again, just in case.
    #Simple Image
    # fig, ([ax1, ax2, ax3, ax4]) = plt.subplots(1, 4, figsize=(16, 3))
    
    # ax1.imshow(R, cmap='Reds', vmax=1, vmin=0)
    # ax1.set_title('Red', fontweight='bold')
    # ax1.axis('off')
    
    # ax2.imshow(G, cmap='Greens', vmax=1, vmin=0)
    # ax2.set_title('Veggie', fontweight='bold')
    # ax2.axis('off')
    
    # ax3.imshow(G_true, cmap='Greens', vmax=1, vmin=0)
    # ax3.set_title('"True" Green', fontweight='bold')
    # ax3.axis('off')
    
    # ax4.imshow(B, cmap='Blues', vmax=1, vmin=0)
    # ax4.set_title('Blue', fontweight='bold')
    # ax4.axis('off')
    
    # plt.subplots_adjust(wspace=.02)
    
    # The RGB array with the raw veggie band
    RGB_veggie = np.dstack([R, G, B])
    
    # The RGB array for the true color image
    RGB = np.dstack([R, G_true, B])
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
    
    # The RGB using the raw veggie band
    ax1.imshow(RGB_veggie)
    ax1.set_title('GOES-16 RGB Raw Veggie', fontweight='bold', loc='left',
                  fontsize=12)
    # ax1.set_title('{}'.format(scan_start.strftime('%d %B %Y %H:%M UTC ')),
    #               loc='right')
    ax1.axis('off')
    
    # The RGB for the true color image
    ax2.imshow(RGB)
    ax2.set_title('GOES-16 RGB True Color', fontweight='bold', loc='left',
                  fontsize=12)
    # ax2.set_title('{}'.format(scan_start.strftime('%d %B %Y %H:%M UTC ')),
    #               loc='right')
    ax2.axis('off')
    
    return


# Initialize S3 file system
fs = s3fs.S3FileSystem(anon=True)
#fs.ls('s3://noaa-goes16/') # Uncomment this line to get the full list of available products 

# Get the fire product files for 1 hour of a specific date
# files = fs.ls('noaa-goes16/ABI-L2-FDCF/2020/228/07/') # list of 6 files for 2020 day 228, UTC time 15:00, 15:10, 15:20, ..., 15:50

#prodbase,plabel='OR_ABI-L2-FDCF-M6_G16_s',['Data Quality Flag','Fire Temperature (K)','Fire Area '+r'$(m^{2})$','Fire Mask','Fire Radiative Power (MW)']
prodbase,plabel='OR_ABI-L2-MCMIPF-M6_G16_s',['True-color-image']


def get_lat_lon(file_system):
    files = file_system.ls('noaa-goes16/ABI-L2-MCMIPF/2020/'+str(232).zfill(3)+'/'+str(14).zfill(2)+'/') # list of 6 files for 2022 day 200, UTC time 15:00, 15:10, 15:20, ..., 15:50
    with fs.open(files[0], 'rb') as f:
      ds0 = xr.open_dataset(BytesIO(f.read()), engine='h5netcdf')

    # sat_h = ds0.goes_imager_projection.perspective_point_height[0] # ubuntu old version
    # sat_lon = ds0.goes_imager_projection.longitude_of_projection_origin[0] # ubuntu old version
    # sat_sweep = ds0.goes_imager_projection.sweep_angle_axis[0] # ubuntu old version
    sat_h = ds0.goes_imager_projection.perspective_point_height # Windows version
    sat_lon = ds0.goes_imager_projection.longitude_of_projection_origin # Windows version
    sat_sweep = ds0.goes_imager_projection.sweep_angle_axis # Windows version
    oproj=ccrs.Geostationary(central_longitude=sat_lon,satellite_height=sat_h,sweep_axis=sat_sweep)
    p = Proj(proj='geos', h=sat_h, lon_0=sat_lon, sweep=sat_sweep)
    X = np.array(ds0.x) * sat_h
    Y = np.array(ds0.y) * sat_h
    XX, YY = np.meshgrid(X,Y)
    rlon, rlat = p(XX, YY, inverse=True)
    
    box=(rlat>=minlat)&(rlat<=maxlat)&(rlon>=minlon)&(rlon<=maxlon)
    # print(np.where(box==True))
    # print(box.astype(int))
    Ib = np.invert(box)
    C = Ib.astype(int)  
    
    return C,oproj



# Define a ROI in degrees
# minlon,maxlon,minlat,maxlat=-72.5,-48.5,-9.5,-5.5
# minlon,maxlon,minlat,maxlat=-58,-56,-18,-16 # cerrado big box
# minlon,maxlon,minlat,maxlat=-57,-54,-9,-6 #Amazon small box
minlon, maxlon, minlat, maxlat = -72, -48, -11, -3  # Amazon definitive box

#minlon,maxlon,minlat,maxlat=-80,-40,-30,5
#minlon,maxlon,minlat,maxlat=-61,-53,-20,-14
#minlon,maxlon,minlat,maxlat=-58,-56,-18,-16
# minlon,maxlon,minlat,maxlat=-57,-56.4,-17,-16.5
# minlon,maxlon,minlat,maxlat=center_point_lon-1.5,center_point_lon+1.5,center_point_lat-1.5,center_point_lat+1.5


#(lat==-7.75) & (lon==-55.25) Central lat and lon of the small area
latitude_centro = -7.75
longitude_centro = -55.25

# small_min_lat = central_lat-0.25
# small_max_lat = central_lat+0.25
# small_min_lon = central_lon-0.25
# small_max_lon = central_lon+0.25

# Lado do quadrado (em graus de latitude e longitude)
lado_quadrado = 0.5

# Calcula as coordenadas dos vÃ©rtices do quadrado
latitudes = [latitude_centro - (lado_quadrado / 2), latitude_centro + (lado_quadrado / 2),
             latitude_centro + (lado_quadrado / 2), latitude_centro - (lado_quadrado / 2),
             latitude_centro - (lado_quadrado / 2)]

longitudes = [longitude_centro - (lado_quadrado / 2), longitude_centro - (lado_quadrado / 2),
              longitude_centro + (lado_quadrado / 2), longitude_centro + (lado_quadrado / 2),
              longitude_centro - (lado_quadrado / 2)]


# Set the projections
#ortho = ccrs.Orthographic(central_longitude=(minlon+maxlon)/2, central_latitude=(minlat+maxlat)/2)
newproj = ccrs.PlateCarree()
geo = ccrs.Geodetic()

# Setup colorbar for DQF: Data Quality Flag
# DQF values as follows: 0 = good quality fire pixel; 1 = good quality land pixel (no fire); 2 = invalid due to clouds; 3 = invalid due to surface type, glint, VZA limits, off earth, or missing input;
# 4 = invalid due to bad input data; 5 = invalid due to algorithm failure
Dcmap = colors.ListedColormap(['red', 'green', 'lightgray', 'blue', 'yellow', 'magenta'])
Dnorm = colors.BoundaryNorm([0, 1, 2, 3, 4, 5, 6], Dcmap.N, clip=True)
Dticks=[0.5,1.5,2.5,3.5,4.5,5.5]
Dyticklabels=['0', '1', '2','3','4','5']
Dvmin, Dvmax=None,None

# Setup colorbar for Fire Temperature (K)
Tcmap = 'inferno'
Tnorm=None
Tticks=[400,500,600,700,800] #,900,1000]
Tyticklabels=['400', '500', '600','700','800'] #,'900','1000']
Tvmin, Tvmax=400,800

# Setup colorbar for Fire Area (m^2)
Acmap = 'inferno'
Anorm=None
Aticks=[0,50000,100000,150000,200000]#,250000,300000]
Ayticklabels=['0', '50 k', '100 k','150 k','200 k']#,'250 k','300 k']
Avmin, Avmax=0,200000

# Setup colorbar for Fire Mask
Mcmap = 'gist_stern'
Mnorm = None
Mticks=[0,10,30,50,100,200,250]
Myticklabels=['0', '10', '30','50','100','200','250']
Mvmin, Mvmax=0,250

# Mcmap = 'gist_stern'
# Mnorm = None
# Mticks=[30,31,32,33,34,35]
# Myticklabels=['30','31','32','33','34','35']
# Mvmin, Mvmax=30,35

# Setup colorbar for Fire Radiative Power (MW)
Pcmap = 'inferno'
Pnorm = None
Pticks=[0,100,200,300,400,500]
Pyticklabels=['0', '100', '200','300','400','500']
Pvmin, Pvmax=0,500

# Plot setup lists
cmaplist=[Dcmap,Tcmap,Acmap,Mcmap,Pcmap]
normlist=[Dnorm,Tnorm,Anorm,Mnorm,Pnorm]
ticklist=[Dticks,Tticks,Aticks,Mticks,Pticks]
ticklabellist=[Dyticklabels,Tyticklabels,Ayticklabels,Myticklabels,Pyticklabels]
minlist=[Dvmin,Tvmin,Avmin,Mvmin,Pvmin]
maxlist=[Dvmax,Tvmax,Avmax,Mvmax,Pvmax]

fig = plt.figure(figsize=(8, 4))
ax = fig.add_subplot(1, 1, 1, projection=newproj)



###################################################################
#Plot box small area
# caixa = mpatches.Polygon(list(zip(longitudes, latitudes)), closed=True, edgecolor='black', facecolor='black',alpha=0.5, transform=newproj)
# ax.add_patch(caixa)

ax.set_extent([minlon, maxlon, minlat, maxlat], crs=geo)
ax.coastlines(resolution='110m')
ax.add_feature(cartopy.feature.LAND)
# ax.add_feature(cartopy.feature.OCEAN)
ax.add_feature(cartopy.feature.COASTLINE,linewidth=1.0)
# ax.add_feature(cartopy.feature.BORDERS, linestyle='-',linewidth=1.0)
# ax.add_feature(cartopy.feature.LAKES)
gl=ax.gridlines(crs=newproj,draw_labels=True,linewidth=0.5, color='black', alpha=0.5, linestyle='--')
gl.xlabels_top=False
gl.ylabels_right=False
gl.xformatter = LongitudeFormatter
gl.yformatter = LatitudeFormatter
#gl.xlabel_style = {'size': 15, 'color': 'gray'}
#gl.xlabel_style = {'color': 'red', 'weight': 'bold'}
# cax = fig.add_axes([ax.get_position().x1+0.01,ax.get_position().y0,0.02,ax.get_position().height])    



C, oproj = get_lat_lon(fs)
# images = []
for d in range(232,233):
    for j in range(14,17):
        files = fs.ls('noaa-goes16/ABI-L2-MCMIPF/2020/'+str(d)+'/'+str(j).zfill(2)+'/') # list of 6 files for 2020 day 228, UTC time 15:00, 15:10, 15:20, ..., 15:50
        print('Processing hour: ' + str(j).zfill(2))              
    # while i<len(files): #len(files):
        for i in range(0,len(files)):
            with fs.open(files[i], 'rb') as f:
                ds = xr.open_dataset(BytesIO(f.read()), engine='h5netcdf')
    
                            

            # M = np.array(ds.DQF)
            # M_box = np.ma.masked_array(M,mask=C)
            # Load the three channels into appropriate R, G, and B variables
            R = ds.CMI_C02
            G = ds.CMI_C03
            B = ds.CMI_C01
            # R = np.ma.masked_array(RF,mask=C)
            # G = np.ma.masked_array(GF,mask=C)
            # B = np.ma.masked_array(BF,mask=C)
            
            # Apply range limits for each channel. RGB values must be between 0 and 1
            R = np.clip(R, 0, 1)
            G = np.clip(G, 0, 1)
            B = np.clip(B, 0, 1)
            # Apply a gamma correction to the image to correct ABI detector brightness
            gamma = 2.2
            R = np.power(R, 1/gamma)
            G = np.power(G, 1/gamma)
            B = np.power(B, 1/gamma)
            # Calculate the "True" Green
            G_true = 0.45 * R + 0.1 * G + 0.45 * B
            G_true = np.clip(G_true, 0, 1)  # apply limits again, just in case.
            
            # The RGB array with the raw veggie band
            # RGB_veggie = np.dstack([R, G, B])
            
            # The RGB array for the true color image
            RGB_box = np.dstack([R, G_true, B])
            # RGB_box = np.ma.masked_array(RGB,mask=C)
        
            starttime=files[i].split(prodbase)[1].split('_')[0]
            year,julian,hhmm=starttime[:4],starttime[4:7],starttime[7:11]
            plottitle=year+'-'+julian+'-'+hhmm
        
            # for j in range(0,len(plabel)):
            #plt.title(plottitle+'    '+plabel[0],loc='center')
            # Z=varlist[0]
            im = ax.imshow(RGB_box,transform=oproj)
            

            
            ax.set_title(plottitle+'    '+plabel[0],loc='center')
            # cb = fig.colorbar(RGB_box,cax=cax, ticks=ticklist[0] ,orientation="vertical",shrink=0.7,pad=0.02)
            # cb.ax.set_yticklabels(ticklabellist[0]) 
            # cb.ax.tick_params(size=0)
            # cb.set_label(plabel[0])
            # plt.colorbar()
            # cb = fig.colorbar(im,cax=cax, ticks=ticklist[3] ,orientation="vertical",shrink=0.7,pad=0.02)
            # cb.ax.set_yticklabels(ticklabellist[3]) 
            # cb.ax.tick_params(size=0)
            # cb.set_label(plabel[0])
            # plt.plot()
            # plt.show()
            plt.savefig('True_color_amazon_definitive box_'+plottitle+'.png', dpi = 100)
            # camera.snap()
            # fig.clear()
    
            print('minute:',i*10)
        
        
            # i=i+1
  
########################################################################################
print('Done')
#######################################################################################


